b_nm2 <- abs(scale(train_X_outlier$num_mortgages)) < 3 #the values are up to three times more
#than the limit of our boxplot, we do remove these values
b_oc2 <- abs(scale(train_X_outlier$num_open_credit)) < 3 #almost all of the observations are
#contained up until thirty so we remove the outliers
b_nr2 <- abs(scale(train_X_outlier$num_records)) < 3 #99% is contained in the first three
#categories of number of records so we remove the outliers
b_ntc2 <- abs(scale(train_X_outlier$num_total_credit)) < 3 #majority of the observations are
#normally distributed so we remove the outliers
b_rb2 <- NULL #outliers are very close to the boxplots so
#keep them, also no steep increase but a gradual increase in outliers
b_ru2 <- abs(scale(train_X_outlier$revol_util)) < 3 #only three outliers, we can remove them
new_train_x2 <- subset(train_X_outlier, (b_ai2&b_dti2&b_ir2&b_mp2&b_nb2&b_nm2&b_oc2&b_nr2&b_ntc2&b_rb2&b_ru2))
nrow(new_train_x2)
new_train_x2
new_train_x2 <- subset(train_X_outlier, (b_ai2&b_dti2&b_nm2&b_oc2&b_nr2&b_ntc2&b_ru2))
new_train_x2
nrow(new_train_x2)
### DATA CLEANING ###
#Import datasets, don't forget to set working directory to source file location
train <- read.csv("../data/bronze/train.csv")
test_X <- read.csv("../data/bronze/test.csv")
head(train)
train_X <- train
ls.str(train_X)
CrossTable(train$default)
CrossTable(train$num_bankrupts)
train_X_impute <- train_X
test_X_impute <- test_X
colMeans(is.na(train_X_impute))
colMeans(is.na(test_X_impute))
naFlag <- function(df, df_val = NULL) {
if (is.null(df_val)) {
df_val <- df
}
mask <- sapply(df_val, anyNA)
out <- lapply(df[mask], function(x)as.numeric(is.na(x)))
if (length(out) > 0) names(out) <- paste0(names(out), "_flag")
return(as.data.frame(out))
}
str(naFlag(df=train_X))
train_X_impute <- cbind(train_X_impute,
naFlag(df = train_X))
test_X_impute <- cbind(test_X_impute,
naFlag(df = test_X, df_val = train_X))
#define the functions for imputing median and mode
impute <- function(x, method = median, val = NULL) {
if (is.null(val)) {
val <- method(x, na.rm = TRUE)
}
x[is.na(x)] <- val
return(x)
}
modus <- function(x, na.rm = FALSE) {
if (na.rm) x <- x[!is.na(x)]
ux <- unique(x)
return(ux[which.max(tabulate(match(x, ux)))])
}
#determine the numeric columns and impute mean value in the train and test set
num.cols <- sapply(train_X_impute, is.numeric)
train_X_impute[, num.cols] <- lapply(train_X_impute[, num.cols],
FUN = impute,
method = median)
test_X_impute$annual_income <- impute(test_X_impute$annual_income, val = median(train_X$annual_income, na.rm = T))
test_X_impute$num_bankrupts <- impute(test_X_impute$num_bankrupts, val = median(train_X$num_bankrupts, na.rm = T))
test_X_impute$num_records   <- impute(test_X_impute$num_records, val = median(train_X$num_records, na.rm = T))
test_X_impute$num_mortgages <- impute(test_X_impute$num_mortgages, val = median(train_X$num_mortgages, na.rm = T))
test_X_impute$num_total_credit <- impute(test_X_impute$num_total_credit, val = median(train_X$num_total_credit, na.rm = T))
test_X_impute$revol_util    <- impute(test_X_impute$revol_util, val = median(train_X$revol_util, na.rm = T))
test_X_impute$monthly_payment <- impute(test_X_impute$monthly_payment, val = median(train_X$monthly_payment, na.rm = T))
#determine the categoric columns and impute the mode in the train and test set
cat.cols <- !num.cols
train_X_impute[, cat.cols] <- lapply(train_X_impute[, cat.cols],
FUN = impute,
method = modus)
test_X_impute[, cat.cols] <- mapply(test_X_impute[, cat.cols],
FUN = impute,
val = sapply(train_X[, cat.cols], modus, na.rm = T))
#We double check our results and spot no more missing values for both the test and train set
colMeans(is.na(train_X_impute))  # -->no more missing values
colMeans(is.na(test_X_impute))   # -->no more missing values
write.csv(train_X_impute, file= "../data/silver/train_with_outlier.csv")
write.csv(test_X_impute, file = "../data/silver/test_cleaned_data.csv")
write.csv(test_X_impute, file = "../data/silver/test_cleaned_data.csv")
train_X_outlier = train_X_impute
#below we can find a easy for loop that shows us which numeric variables contain outliers
num.cols <- sapply(train_X_impute, is.numeric)
all_cols <- colnames(train_X)[num.cols]
for (i in all_cols[2:13]){
print(paste0("column name:",i,"  ",sum(abs(scale(train_X_outlier[i]))>3)))
}
#we create all the conditions for which rows we want to remove because they contain an outlier
b_ai <- abs(scale(train_X_outlier$annual_income)) < 3
b_dti <- abs(scale(train_X_outlier$debt_to_income)) < 3
b_ir <- abs(scale(train_X_outlier$interest_rate)) < 3
b_mp <- abs(scale(train_X_outlier$monthly_payment)) < 3
b_nb <- abs(scale(train_X_outlier$num_bankrupts)) < 3
b_nm <- abs(scale(train_X_outlier$num_mortgages)) < 3
b_oc <- abs(scale(train_X_outlier$num_open_credit)) < 3
b_nr <- abs(scale(train_X_outlier$num_records)) < 3
b_ntc <- abs(scale(train_X_outlier$num_total_credit)) < 3
b_rb <- abs(scale(train_X_outlier$revol_balance)) < 3
b_ru <- abs(scale(train_X_outlier$revol_util)) < 3
#we subset from our original dataset for which the outlier conditions are ALWAYS true,
#in other words, if one of the conditions is false we drop the whole row
new_train_x <- subset(train_X_outlier, (b_ai&b_dti&b_ir&b_mp&b_nb&b_nm&b_oc&b_nr&b_ntc&b_rb&b_ru))
new_test_x <- test_X_outlier
write.csv(new_train_x, file= "../data/silver/train_cleaned_data.csv")
train_X_outlier = train_X_impute
#define outlier function that replaces the outlier with a mean value?
handle_outlier_z <- function(col){
col_z <- scale(col)
ifelse(abs(col_z)>3,
sign(col_z)*3*attr(col_z,"scaled:scale") + attr(col_z,"scaled:center"), col)
}
#We now change all outlier values to NA values
num.cols <- sapply(train_X, is.numeric)
train_X_outlier[,all_cols[2:13]] <-  sapply(train_X[,all_cols[2:13]], FUN = handle_outlier_z)
#we see several of the columns now containg NA values
for (i in all_cols[2:13]){
print(paste0("column name:",i,"  ",sum(abs(scale(train_X_outlier[i]))>3)))
}
#We impute those NA values again like step 1
impute <- function(x, method = median, val = NULL) {
if (is.null(val)) {
val <- method(x, na.rm = TRUE)
}
x[is.na(x)] <- val
return(x)
}
num.cols <- sapply(train_X_impute, is.numeric)
train_X_outlier[, num.cols] <- lapply(train_X_outlier[, num.cols],
FUN = impute,
method = median)
write.csv(train_X_outlier, file= "../data/silver/train_cleaned_NA_data.csv")
train_X_outlier = train_X_impute
b_ai2 <- abs(scale(train_X_outlier$annual_income)) < 3 #INCREDIBLY skewed results, remove them all
b_dti2 <- (train_X_outlier$debt_to_income < 1500) #Only one value that is bad (1600+),
#remove this value, also self reported so could be wrong data, remove!
b_ir2 <- NULL #outliers are not really that bad
#and the values make sens, so we don't remove any of them (see boxplots)
b_mp2 <- NULL # gradual increase of our outlier, 922 outliers but there are
#no crazy values so we keep them
b_nb2 <- NULL #Very important! Don't drop these!
#this shows us that the people that take out a loan are people with 0 or 7 bankruptcies!
b_nm2 <- abs(scale(train_X_outlier$num_mortgages)) < 3 #the values are up to three times more
#than the limit of our boxplot, we do remove these values
b_oc2 <- abs(scale(train_X_outlier$num_open_credit)) < 3 #almost all of the observations are
#contained up until thirty so we remove the outliers
b_nr2 <- abs(scale(train_X_outlier$num_records)) < 3 #99% is contained in the first three
#categories of number of records so we remove the outliers
b_ntc2 <- abs(scale(train_X_outlier$num_total_credit)) < 3 #majority of the observations are
#normally distributed so we remove the outliers
b_rb2 <- NULL #outliers are very close to the boxplots so
#keep them, also no steep increase but a gradual increase in outliers
b_ru2 <- abs(scale(train_X_outlier$revol_util)) < 3 #only three outliers, we can remove them
new_train_x2 <- subset(train_X_outlier, (b_ai2&b_dti2&b_nm2&b_oc2&b_nr2&b_ntc2&b_ru2))
write.csv(new_train_x2, file= "../data/silver/train_cleaned_less_restrictive_data.csv")
train_X <- subset(train, select = -c(Default))
train_X <- subset(train, select = -c("Default"))
train_X <- subset(train, select = -c(default))
train_y <- train$def
train_y <- train$default
train_y
train_X$home_status
train_X <- subset(train, select = -c(default))
train_y <- train$default
train_X$home_status
### DATA CLEANING ###
#Import datasets, don't forget to set working directory to source file location
train <- read.csv("../data/bronze/train.csv")
test_X <- read.csv("../data/bronze/test.csv")
head(train)
train_X <- train
ls.str(train_X)
CrossTable(train$default)
CrossTable(train$num_bankrupts)
train_X_impute <- train_X
test_X_impute <- test_X
colMeans(is.na(train_X_impute))
colMeans(is.na(test_X_impute))
naFlag <- function(df, df_val = NULL) {
if (is.null(df_val)) {
df_val <- df
}
mask <- sapply(df_val, anyNA)
out <- lapply(df[mask], function(x)as.numeric(is.na(x)))
if (length(out) > 0) names(out) <- paste0(names(out), "_flag")
return(as.data.frame(out))
}
str(naFlag(df=train_X))
train_X_impute <- cbind(train_X_impute,
naFlag(df = train_X))
test_X_impute <- cbind(test_X_impute,
naFlag(df = test_X, df_val = train_X))
#define the functions for imputing median and mode
impute <- function(x, method = median, val = NULL) {
if (is.null(val)) {
val <- method(x, na.rm = TRUE)
}
x[is.na(x)] <- val
return(x)
}
modus <- function(x, na.rm = FALSE) {
if (na.rm) x <- x[!is.na(x)]
ux <- unique(x)
return(ux[which.max(tabulate(match(x, ux)))])
}
#determine the numeric columns and impute mean value in the train and test set
num.cols <- sapply(train_X_impute, is.numeric)
train_X_impute[, num.cols] <- lapply(train_X_impute[, num.cols],
FUN = impute,
method = median)
test_X_impute$annual_income <- impute(test_X_impute$annual_income, val = median(train_X$annual_income, na.rm = T))
test_X_impute$num_bankrupts <- impute(test_X_impute$num_bankrupts, val = median(train_X$num_bankrupts, na.rm = T))
test_X_impute$num_records   <- impute(test_X_impute$num_records, val = median(train_X$num_records, na.rm = T))
test_X_impute$num_mortgages <- impute(test_X_impute$num_mortgages, val = median(train_X$num_mortgages, na.rm = T))
test_X_impute$num_total_credit <- impute(test_X_impute$num_total_credit, val = median(train_X$num_total_credit, na.rm = T))
test_X_impute$revol_util    <- impute(test_X_impute$revol_util, val = median(train_X$revol_util, na.rm = T))
test_X_impute$monthly_payment <- impute(test_X_impute$monthly_payment, val = median(train_X$monthly_payment, na.rm = T))
#determine the categoric columns and impute the mode in the train and test set
cat.cols <- !num.cols
train_X_impute[, cat.cols] <- lapply(train_X_impute[, cat.cols],
FUN = impute,
method = modus)
test_X_impute[, cat.cols] <- mapply(test_X_impute[, cat.cols],
FUN = impute,
val = sapply(train_X[, cat.cols], modus, na.rm = T))
#We double check our results and spot no more missing values for both the test and train set
colMeans(is.na(train_X_impute))  # -->no more missing values
colMeans(is.na(test_X_impute))   # -->no more missing values
train_X_outlier = train_X_impute
#below we can find a easy for loop that shows us which numeric variables contain outliers
num.cols <- sapply(train_X_impute, is.numeric)
all_cols <- colnames(train_X)[num.cols]
for (i in all_cols[2:13]){
print(paste0("column name:",i,"  ",sum(abs(scale(train_X_outlier[i]))>3)))
}
#we create all the conditions for which rows we want to remove because they contain an outlier
b_ai <- abs(scale(train_X_outlier$annual_income)) < 3
b_dti <- abs(scale(train_X_outlier$debt_to_income)) < 3
b_ir <- abs(scale(train_X_outlier$interest_rate)) < 3
b_mp <- abs(scale(train_X_outlier$monthly_payment)) < 3
b_nb <- abs(scale(train_X_outlier$num_bankrupts)) < 3
b_nm <- abs(scale(train_X_outlier$num_mortgages)) < 3
b_oc <- abs(scale(train_X_outlier$num_open_credit)) < 3
b_nr <- abs(scale(train_X_outlier$num_records)) < 3
b_ntc <- abs(scale(train_X_outlier$num_total_credit)) < 3
b_rb <- abs(scale(train_X_outlier$revol_balance)) < 3
b_ru <- abs(scale(train_X_outlier$revol_util)) < 3
#we subset from our original dataset for which the outlier conditions are ALWAYS true,
#in other words, if one of the conditions is false we drop the whole row
new_train_x <- subset(train_X_outlier, (b_ai&b_dti&b_ir&b_mp&b_nb&b_nm&b_oc&b_nr&b_ntc&b_rb&b_ru))
nrow(new_train_x)
write.csv(new_train_x, file= "../data/silver/train_cleaned_data.csv")
train <- read.csv("../data/silver/train_cleaned_data.csv")
nrow(train)
new_train_x$home_status
train_X$home_status
nrow(train)
train$home_status
train <- read.csv("../data/silver/train_cleaned_data.csv")
#train <- read.csv("../data/silver/train_cleaned_less_restrictive_data.csv")
#train <- read.csv("../data/silver/train_cleaned_NA_data.csv")
#train <- read.csv("../data/silver/train_cleaned_with_outlier.csv")
test_X <- read.csv("../data/silver/test_cleaned_data.csv")
train_X <- subset(train, select = -c(default))
train_y <- train$default
train_X$home_status
#train <- read.csv("../data/silver/train_cleaned_data.csv")
train <- read.csv("../data/silver/train_cleaned_less_restrictive_data.csv")
train_X <- subset(train, select = -c(default))
train_y <- train$default
train_X$home_status
nrow(train_X)
#train <- read.csv("../data/silver/train_cleaned_data.csv")
#train <- read.csv("../data/silver/train_cleaned_less_restrictive_data.csv")
train <- read.csv("../data/silver/train_cleaned_NA_data.csv")
#train <- read.csv("../data/silver/train_cleaned_with_outlier.csv")
test_X <- read.csv("../data/silver/test_cleaned_data.csv")
train_X <- subset(train, select = -c(default))
train_y <- train$default
train_X$home_status
nrow(train_X)
train <- read.csv("../data/silver/train_cleaned_data.csv")
#train <- read.csv("../data/silver/train_cleaned_less_restrictive_data.csv")
#train <- read.csv("../data/silver/train_cleaned_NA_data.csv")
#train <- read.csv("../data/silver/train_cleaned_with_outlier.csv")
test_X <- read.csv("../data/silver/test_cleaned_data.csv")
train_X <- subset(train, select = -c(default))
train_y <- train$default
train_X$home_status
nrow(train_X)
##check all possible values for home status
unique(train_X$home_status)
#We will create a new variable called UNKNOWN and add the NONE OTHER ANY to this
train_X$home_status == "NONE"
#We will create a new variable called UNKNOWN and add the NONE OTHER ANY to this
train_X$home_status[train_X$home_status == "NONE"]
#We will create a new variable called UNKNOWN and add the NONE OTHER ANY to this
train_X$home_status[train_X$home_status == "NONE"] <- "UNKNOWN"
train_X$home_status[train_X$home_status == "NONE"]
train_X$home_status[train_X$home_status == "UNKNOWN"]
train_X$home_status[train_X$home_status == "OTHER"] <- "UNKNOWN"
train_X <- subset(train, select = -c(default))
##check all possible values for home status
unique(train_X$home_status) #MORTAGE RENT OWN NONE OTHER ANY
#We will Register the "ANY" observations as "OTHER" observations and retain the "NONE" observations
#(the "NONE" column functions as NA indicator)
train_X$home_status[train_X$home_status == "ANY"] <- "OTHER"
#The NONE information will be seen as an NA value which we impute with the mode of "
table(train_X$home_status)
train_X$home_status[train_X$home_status == "NONE"] <- "MORTAGE"
unique(train_X$home_status)
train_X$home_status[train_X$home_status == "NONE"] <- "MORTGAGE"
unique(train_X$home_status)
train_X <- subset(train, select = -c(default))
train_y <- train$default
##check all possible values for home status
unique(train_X$home_status) #MORTAGE RENT OWN NONE OTHER ANY
#We will Register the "ANY" observations as "OTHER" observations and retain the "NONE" observations
#(the "NONE" column functions as NA indicator)
train_X$home_status[train_X$home_status == "ANY"] <- "OTHER"
#The NONE information will be seen as an NA value which we impute with the mode of "
table(train_X$home_status)
train_X$home_status[train_X$home_status == "NONE"] <- "MORTGAGE"
unique(train_X$home_status)
unique(test_X_fe$home_status)
#train <- read.csv("../data/silver/train_cleaned_less_restrictive_data.csv")
#train <- read.csv("../data/silver/train_cleaned_NA_data.csv")
#train <- read.csv("../data/silver/train_cleaned_with_outlier.csv")
test_X_fe <- read.csv("../data/silver/test_cleaned_data.csv")
unique(test_X_fe$home_status)
library(dummy)
library(dummies)
library(dummy)
install.packages(ISLR2)
library(dummy)
install.packages(dummy)
install.packages("dummy")
library(dummy)
cats <- categories(train_X[,c("home_status")])
cats <- categories(train_X$home_status)
cats <- categories(data.frame(train_X$home_status))
cats
cats <- categories(data.frame(train_X[,c("home_status"])))
cats <- categories(data.frame(train_X[,c("home_status")]))
cats
cats <- categories(data.frame(train_X$home_status)
dummies_train <- dummy(data.frame(train_X[,c("home_status")]), object = cats)
dummies_train <- dummy(data.frame(train_X[,c("home_status")]),
object = cats)
dummies_train <- subset(dummies_train, select = -c(home_status))
dummies_train <- subset(dummies_train, select = -c("home_status"))
library(dummy)
train <- read.csv("../data/bronze/train.csv")
test_X <- read.csv("../data/bronze/test.csv")
train_y <- train$default
train_X <- subset(train, select = -c(default))
train_X_impute <- train_X
test_X_impute <- test_X
unique(train_X_impute$grade)
unique(train_X_impute$sub_grade)
grade_levels <- c("A", "B", "C", "D", "E", "F", "G")
train_X_impute$grade <- as.numeric(factor(train_X_impute$grade, levels = grade_levels))
test_X_impute$grade <- as.numeric(factor(test_X_impute$grade, levels = grade_levels))
subgrade_levels <- c("A1", "A2", "A3", "A4", "A5",
"B1", "B2", "B3", "B4", "B5",
"C1", "C2", "C3", "C4", "C5",
"D1", "D2", "D3", "D4", "D5",
"E1", "E2", "E3", "E4", "E5",
"F1", "F2", "F3", "F4", "F5")
train_X_impute$sub_grade <- as.numeric(factor(train_X_impute$sub_grade, levels = subgrade_levels))
test_X_impute$sub_grade <- as.numeric(factor(test_X_impute$sub_grade, levels = subgrade_levels))
train_X_impute$sub_grade
match <- regmatches(train_X_impute$date_funded, regexec("[0-9]{4}", train_X_impute$date_funded))
train_X_impute$date_funded <- sapply(match, `[`, 1)
match2 <- regmatches(test_X_impute$date_funded, regexec("[0-9]{4}", test_X_impute$date_funded))
test_X_impute$date_funded <- sapply(match2, `[`, 1)
match3 <- regmatches(train_X_impute$earliest_cr_line, regexec("[0-9]{4}", train_X_impute$earliest_cr_line))
train_X_impute$earliest_cr_line <- sapply(match3, `[`, 1)
match4 <- regmatches(test_X_impute$earliest_cr_line, regexec("[0-9]{4}", test_X_impute$earliest_cr_line))
test_X_impute$earliest_cr_line <- sapply(match4, `[`, 1)
train_X_impute$date_funded <- as.numeric(train_X_impute$date_funded)
train_X_impute$earliest_cr_line <- as.numeric(train_X_impute$earliest_cr_line)
test_X_impute$date_funded <- as.numeric(test_X_impute$date_funded)
test_X_impute$earliest_cr_line <- as.numeric(test_X_impute$earliest_cr_line)
train_X_impute$year_customer <- train_X_impute$date_funded - train_X_impute$earliest_cr_line
test_X_impute$years_customer <- test_X_impute$date_funded - test_X_impute$earliest_cr_line
#drop column date_funded and earliest_cr_line:
train_X_impute <- subset(train_X_impute, select = -c(date_funded,earliest_cr_line))
test_X_impute <- subset(test_X_impute, select=  -c(date_funded,earliest_cr_line))
cats <- categories(data.frame(train_X_impute$income_verif_status))
cats
# apply on train set (exclude reference categories)
dummies_train <- dummy(data.frame(train_X_impute$income_verif_status),object = cats)
dummies_train
#rename vars:
names(dummies_train)[1] <- "income_status_not_verified"
names(dummies_train)[2] <- "income_status_source_verified"
names(dummies_train)[3] <- "income_status_verified"
#exclude reference category (first column):
dummies_train <- subset(dummies_train, select = -c(income_status_not_verified))
head(test_X_impute$income_verif_status)
# apply on test set:
dummies_test <- dummy(data.frame(test_X_impute$income_verif_status), object = cats)
dummies_train
head(test_X_impute$income_verif_status)
unique(test_X_impute)
unique(test_X_impute$income_verif_status)
# apply on test set:
dummies_test <- dummy(data.frame(test_X_impute$income_verif_status), object = cats)
# apply on test set:
dummies_test <- dummy(test_X_impute$income_verif_status, object = cats)
# apply on test set:
dummies_test <- dummy(data.frame(test_X_impute$income_verif_status), object = cats)
cats <- categories(data.frame(train_X_impute$income_verif_status))
# apply on train set (exclude reference categories)
dummies_train <- dummy(data.frame(train_X_impute$income_verif_status),object = cats)
dummies_train
#rename vars:
colnames(dummies_train)
#rename vars:
colnames(dummies_train) <- c("income_status_not_verified", "income_status_source_verified",
"income_status_verified")
dummies_train
#exclude reference category (first column):
dummies_train <- subset(dummies_train, select = -c(income_status_not_verified))
head(test_X_impute$income_verif_status)
# apply on test set:
dummies_test <- dummy(data.frame(test_X_impute$income_verif_status), object = cats)
colnames(test_X_impute)
# apply on test set:
dummies_test <- dummy(data.frame(test_X_impute$income_verif_status), object = cats)
# apply on test set:
dummies_test <- dummy(test_X_impute$income_verif_status, object = cats)
train_X_impute <- train_X
test_X_impute <- test_X
cats <- categories(data.frame(train_X_impute$income_verif_status))
cats
# apply on train set (exclude reference categories)
dummies_train <- dummy(data.frame(train_X_impute$income_verif_status),object = cats)
dummies_train
#rename vars:
colnames(dummies_train) <- c("income_status_not_verified", "income_status_source_verified",
"income_status_verified")
#exclude reference category (first column):
dummies_train <- subset(dummies_train, select = -c(income_status_not_verified))
head(test_X_impute$income_verif_status)
colnames(test_X_impute)
# apply on test set:
dummies_test <- dummy(test_X_impute$income_verif_status, object = cats)
# apply on test set:
dummies_test <- dummy(data.frame(test_X_impute$income_verif_status), object = cats)
# apply on test set:
dummies_test <- dummy(c(test_X_impute$income_verif_status), object = cats)
head(test_X_impute$income_verif_status)
unique(test_X_impute$income_verif_status)
train_X_impute <- train_X
test_X_impute <- test_X
cats <- categories(data.frame(train_X_impute$income_verif_status))
cats
# apply on train set (exclude reference categories)
dummies_train <- dummy(data.frame(train_X_impute$income_verif_status),object = cats)
dummies_test <- dummy(data.frame(test_X_impute$income_verif_status), object = cats)
#################
#DATA EXPLORATION
#################
train <- read.csv("../data/bronze/train.csv")
test_X <- read.csv("../data/bronze/test.csv")
head(train)
#Create our training sets
train_X <- subset(train, select = -c(default))
train_y <- train$default
ls.str(train_X)
num.cols <- sapply(train_X_impute, is.numeric)
train_X_num <- train_X[ ,num.cols]
train_X_num
train_X[columns == num.cols]
hist(train_X$amount)
hist(train_X$annual_income)
boxplot(train_X$annual_income) #CLEAR indication of outliers, we should probably remove some of them
#missing values?
sum(is.na(train_X$application_type)) #no missing values
#unique categories?
unique(train_X$application_type) #3 different categories: Individual, Direct_Pay and Joint --> create dummy variables on the 3?
#how many times does every category occurs
table(train_X$application_type, useNA = "ifany") #direct pay: 75, individual: 70813, joint: 66
barplot(prop.table(table(train_X$application_type)))
barplot(prop.table(table(train_X$grade, useNA = "ifany")),las = 2)
prop.table(table(train_X$home_status, useNA = "ifany"))
barplot(prop.table(table(train_X$num_records, useNA = "ifany")),las = 2)
barplot(prop.table(table(train_X$num_mortgages, useNA = "ifany")),las = 2)
barplot(prop.table(table(train_X$num_total_credit, useNA = "ifany")),las = 2)
boxplot(train_X$revol_util)
new_train_x2 <- subset(train_X_outlier, (b_ai2&b_dti2&b_ru2))
write.csv(new_train_x2, file= "../data/silver/train_cleaned_less_restrictive_data.csv")
library(randomForest)
library(randomForest)
library(randomForest)
train <- read.csv("../data/silver/train_cleaned_data.csv")
#train <- read.csv("../data/silver/train_cleaned_less_restrictive_data.csv")
#train <- read.csv("../data/silver/train_cleaned_NA_data.csv")
#train <- read.csv("../data/silver/train_cleaned_with_outlier.csv")
test_X_fe <- read.csv("../data/silver/test_cleaned_data.csv")
train_X_fe <- subset(train, select = -c(default))
train_y <- train$default
bin_data_frequency <- function(x_train, x_val, bins = 5) {
cut(x_val, breaks = quantile(x_train, seq(0, 1, 1 / bins)), include.lowest = TRUE)
}
#train <- read.csv("../data/silver/train_cleaned_data.csv")
train <- read.csv("../data/silver/train_cleaned_less_restrictive_data.csv")
train_X_fe$num_records
