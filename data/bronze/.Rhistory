train_X_fe[train_X_fe$state == 'W']
ls.str(train_X_impute)
ls.str(test_X_impute)
train_X_impute <- train_X
test_X_impute <- test_X
colMeans(is.na(train_X_impute))
naFlag <- function(df, df_val = NULL) {
if (is.null(df_val)) {
df_val <- df
}
mask <- sapply(df_val, anyNA)
out <- lapply(df[mask], function(x)as.numeric(is.na(x)))
if (length(out) > 0) names(out) <- paste0(names(out), "_flag")
return(as.data.frame(out))
}
str(naFlag(df=train_X))
train_X_impute <- cbind(train_X_impute,
naFlag(df = train_X))
test_X_impute <- cbind(test_X_impute,
naFlag(df = test_X, df_val = train_X))
str(naFlag(df=train_X))
train_X_impute <- cbind(train_X_impute,
naFlag(df = train_X))
test_X_impute <- cbind(test_X_impute,
naFlag(df = test_X, df_val = train_X))
cols.dont.want <- c('annual_income_flag',
'emp_length_flag',
'emp_title_flag',
'monthly_payment_flag',
'num_bankrupts_flag',
'num_mortgages_flag',
'num_records_flag'  ,
'num_total_credit_flag',
'revol_util_flag')
train_X_impute = train_X_impute[ , ! names(train_X_impute) %in% cols.dont.want]
test_X_impute = test_X_impute[ , ! names(test_X_impute) %in% cols.dont.want]
impute <- function(x, method = mean, val = NULL) {
if (is.null(val)) {
val <- method(x, na.rm = TRUE)
}
x[is.na(x)] <- val
return(x)
}
modus <- function(x, na.rm = FALSE) {
if (na.rm) x <- x[!is.na(x)]
ux <- unique(x)
return(ux[which.max(tabulate(match(x, ux)))])
}
num.cols <- sapply(train_X_impute, is.numeric)
train_X_impute[, num.cols] <- lapply(train_X_impute[, num.cols],
FUN = impute,
method = mean)
#--------------------------------------------------------------STRANGE
test_X_impute[, num.cols] <- mapply(test_X_impute[, num.cols],
FUN = impute,
val = mean(train_X$num.cols ,na.rm = T))
#--------------------------------------------------------------STRANGE
test_X_impute[, num.cols] <- mapply(test_X_impute[, num.cols],
FUN = impute,
val = colMeans(train_X$num.cols ,na.rm = T))
#--------------------------------------------------------------STRANGE
test_X_impute[, num.cols] <- mapply(test_X_impute[, num.cols],
FUN = impute,
val = colMeans(train_X[,num.cols] ,na.rm = T))
ls.str(train_X_impute)
ls.str(test_X_impute)
train_X_fe <- train_X_impute
test_X_fe <- test_X_impute
train_X_fe <- as.data.frame(unclass(train_X_fe), stringsAsFactors = T)
test_X_fe <- as.data.frame(unclass(test_X_fe), stringsAsFactors = T)
num.cols <- sapply(train_X_fe, is.numeric)
mean_train <- colMeans(train_X_fe[, num.cols])
sd_train <- sapply(train_X_fe[, num.cols], sd)
train_X_fe[, num.cols] <- scale(train_X_fe[, num.cols], center = TRUE, scale = TRUE)
num.cols <- sapply(test_X_fe, is.numeric)
mean_train <- colMeans(test_X_fe[, num.cols])
sd_train <- sapply(test_X_fe[, num.cols], sd)
test_X_fe[, num.cols] <- scale(test_X_fe[, num.cols], center = TRUE, scale = TRUE)
train_y <- as.factor(train_y)
#small glitch
#train_X_fe <- train_X_fe[train_X_fe$state != 'WN',]
########################################################
class(train_X_fe_mod$state)
ls.str(train_X_impute)
ls.str(test_X_impute)
vec <- c('application_type','emp_length', 'emp_title', 'grade',
'home_status', 'income_verif_status', 'state',
'home_status_flag', 'sub_grade', 'term')
train_X_fe <- train_X_impute
test_X_fe <- test_X_impute
train_X_fe <- as.data.frame(unclass(train_X_fe), stringsAsFactors = T)
test_X_fe <- as.data.frame(unclass(test_X_fe), stringsAsFactors = T)
num.cols <- sapply(train_X_fe, is.numeric)
mean_train <- colMeans(train_X_fe[, num.cols])
sd_train <- sapply(train_X_fe[, num.cols], sd)
train_X_fe[, num.cols] <- scale(train_X_fe[, num.cols], center = TRUE, scale = TRUE)
num.cols <- sapply(test_X_fe, is.numeric)
mean_train <- colMeans(test_X_fe[, num.cols])
sd_train <- sapply(test_X_fe[, num.cols], sd)
test_X_fe[, num.cols] <- scale(test_X_fe[, num.cols], center = TRUE, scale = TRUE)
train_y <- as.factor(train_y)
library(randomForest)
set.seed(1)
#small glitch
#train_X_fe <- train_X_fe[train_X_fe$state != 'WN',]
########################################################
class(train_X_fe_mod$state)
train_X_fe_mod <- droplevels(train_X_fe, exclude = "WY")
colMeans(is.na(train_X_fe))
colMeans(is.na(test_X_fe))
fit <- randomForest(train_y ~.,data = train_X_fe, mtry = 5, ntree = 25)
fit <- randomForest(x = train_X_fe, y = train_y, mtry = 5, ntree = 25)
y_estimate <- predict(fit,xtest)
cf.test <- table(y_estimate,train_y)
## id is character en default is numeric
y_estimate <- as.numeric(as.character(y_estimate))
test_X$id <- as.character(test_X$id)
class(y_estimate)
class(test_X$id)
rf_preds_df <- data.frame(id = test_X$id, default = y_estimate)
write.csv(rf_preds_df, file = "C:\\Users\\Milan\\Documents\\Master hir 1\\Machine Learning Dries Benoit\\KaggleComp\\model1.csv", row.names = F)
?write.csv
rf_preds_df <- data.frame(id = test_X$id, default = y_estimate)
fit <- randomForest(train_y ~.,data = train_X_fe, mtry = 5, ntree = 25)
### DATA CLEANING ###
train <- read.csv("train.csv")
test_X <- read.csv("test.csv")
head(train)
train_X <- subset(train, select = -c(default))
train_y <- train$default
ls.str(train_X)
CrossTable(train$default)
CrossTable(train$num_bankrupts)
CrossTable(train_X_fe$state)
train_X_fe[train_X_fe$state == 'W']
train_X_impute <- train_X
test_X_impute <- test_X
colMeans(is.na(train_X_impute))
colMeans(is.na(test_X_impute))
naFlag <- function(df, df_val = NULL) {
if (is.null(df_val)) {
df_val <- df
}
mask <- sapply(df_val, anyNA)
out <- lapply(df[mask], function(x)as.numeric(is.na(x)))
if (length(out) > 0) names(out) <- paste0(names(out), "_flag")
return(as.data.frame(out))
}
str(naFlag(df=train_X))
train_X_impute <- cbind(train_X_impute,
naFlag(df = train_X))
test_X_impute <- cbind(test_X_impute,
naFlag(df = test_X, df_val = train_X))
cols.dont.want <- c('annual_income_flag',
'emp_length_flag',
'emp_title_flag',
'monthly_payment_flag',
'num_bankrupts_flag',
'num_mortgages_flag',
'num_records_flag'  ,
'num_total_credit_flag',
'revol_util_flag')
train_X_impute = train_X_impute[ , ! names(train_X_impute) %in% cols.dont.want]
test_X_impute = test_X_impute[ , ! names(test_X_impute) %in% cols.dont.want]
impute <- function(x, method = mean, val = NULL) {
if (is.null(val)) {
val <- method(x, na.rm = TRUE)
}
x[is.na(x)] <- val
return(x)
}
modus <- function(x, na.rm = FALSE) {
if (na.rm) x <- x[!is.na(x)]
ux <- unique(x)
return(ux[which.max(tabulate(match(x, ux)))])
}
num.cols <- sapply(train_X_impute, is.numeric)
train_X_impute[, num.cols] <- lapply(train_X_impute[, num.cols],
FUN = impute,
method = mean)
#--------------------------------------------------------------STRANGE
test_X_impute[, num.cols] <- mapply(test_X_impute[, num.cols],
FUN = impute,
val = colMeans(train_X[,num.cols] ,na.rm = T))
test_X_impute$annual_income <- impute(test_X_impute$annual_income, val = mean(train_X$annual_income, na.rm = T))
test_X_impute$num_bankrupts <- impute(test_X_impute$num_bankrupts, val = mean(train_X$num_bankrupts, na.rm = T))
test_X_impute$num_records   <- impute(test_X_impute$num_records, val = mean(train_X$num_records, na.rm = T))
test_X_impute$num_mortgages <- impute(test_X_impute$num_mortgages, val = mean(train_X$num_mortgages, na.rm = T))
test_X_impute$num_total_credit <- impute(test_X_impute$num_total_credit, val = mean(train_X$num_total_credit, na.rm = T))
test_X_impute$revol_util    <- impute(test_X_impute$revol_util, val = mean(train_X$revol_util, na.rm = T))
test_X_impute$monthly_payment <- impute(test_X_impute$monthly_payment, val = mean(train_X$monthly_payment, na.rm = T))
cat.cols <- !num.cols
train_X_impute[, cat.cols] <- lapply(train_X_impute[, cat.cols],
FUN = impute,
method = modus)
test_X_impute[, cat.cols] <- mapply(test_X_impute[, cat.cols],
FUN = impute,
val = sapply(train_X[, cat.cols], modus, na.rm = T))
colMeans(is.na(train_X_impute))  # -->no more missing values
colMeans(is.na(test_X_impute))   # -->no more missing values
match <- regmatches(train_X_impute$address, regexec("[A-Z][A-Z]", train_X_impute$address))
match <- regmatches(test_X_impute$address, regexec("[A-Z][A-Z]", test_X_impute$address))
train_X_impute$state <- sapply(match, `[`, 1)
test_X_impute$state <- sapply
cats <- categories(train_X_encode[, c("State")], p = 10)
col.to.drop <- c('address')
train_X_impute = train_X_impute[ , ! names(train_X_impute) %in% col.to.drop]
test_X_impute = test_X_impute[ , ! names(test_X_impute) %in% col.to.drop]
head(train_X_impute)
M <-cor(train_X_impute[sapply(train_X_impute,is.numeric)])
corrplot(M, type="upper", order="hclust",col=brewer.pal(n=8, name="RdYlBu"))
cols.to.drop <- c('earliest_cr_line', 'date_funded', 'address')
train_X_impute = train_X_impute[ , ! names(train_X_impute) %in% cols.to.drop]
test_X_impute = test_X_impute[ , ! names(test_X_impute) %in% cols.to.drop]
install.packages("gmodels")
install.packages("gmodels")
library(gmodels)
library(corrplot)
library(RColorBrewer)
### DATA CLEANING ###
train <- read.csv("./GitHub/ml21-group07/data/bronze/train.csv")
test_X <- read.csv("./GitHub/ml21-group07/data/bronze/test.csv")
head(train)
train_X <- subset(train, select = -c(default))
train_y <- train$default
ls.str(train_X)
CrossTable(train$default)
CrossTable(train$num_bankrupts)
CrossTable(train_X_fe$state)
train_X_fe[train_X_fe$state == 'W']
train_X_impute <- train_X
test_X_impute <- test_X
colMeans(is.na(train_X_impute))
colMeans(is.na(test_X_impute))
naFlag <- function(df, df_val = NULL) {
if (is.null(df_val)) {
df_val <- df
}
mask <- sapply(df_val, anyNA)
out <- lapply(df[mask], function(x)as.numeric(is.na(x)))
if (length(out) > 0) names(out) <- paste0(names(out), "_flag")
return(as.data.frame(out))
}
str(naFlag(df=train_X))
train_X_impute <- cbind(train_X_impute,
naFlag(df = train_X))
test_X_impute <- cbind(test_X_impute,
naFlag(df = test_X, df_val = train_X))
cols.dont.want <- c('annual_income_flag',
'emp_length_flag',
'emp_title_flag',
'monthly_payment_flag',
'num_bankrupts_flag',
'num_mortgages_flag',
'num_records_flag'  ,
'num_total_credit_flag',
'revol_util_flag')
train_X_impute = train_X_impute[ , ! names(train_X_impute) %in% cols.dont.want]
test_X_impute = test_X_impute[ , ! names(test_X_impute) %in% cols.dont.want]
impute <- function(x, method = mean, val = NULL) {
if (is.null(val)) {
val <- method(x, na.rm = TRUE)
}
x[is.na(x)] <- val
return(x)
}
modus <- function(x, na.rm = FALSE) {
if (na.rm) x <- x[!is.na(x)]
ux <- unique(x)
return(ux[which.max(tabulate(match(x, ux)))])
}
num.cols <- sapply(train_X_impute, is.numeric)
train_X_impute[, num.cols] <- lapply(train_X_impute[, num.cols],
FUN = impute,
method = mean)
#--------------------------------------------------------------STRANGE
test_X_impute[, num.cols] <- mapply(test_X_impute[, num.cols],
FUN = impute,
val = mean(train_X$num.cols ,na.rm = T))
test_X_impute$annual_income <- impute(test_X_impute$annual_income, val = mean(train_X$annual_income, na.rm = T))
test_X_impute$num_bankrupts <- impute(test_X_impute$num_bankrupts, val = mean(train_X$num_bankrupts, na.rm = T))
test_X_impute$num_records   <- impute(test_X_impute$num_records, val = mean(train_X$num_records, na.rm = T))
test_X_impute$num_mortgages <- impute(test_X_impute$num_mortgages, val = mean(train_X$num_mortgages, na.rm = T))
test_X_impute$num_total_credit <- impute(test_X_impute$num_total_credit, val = mean(train_X$num_total_credit, na.rm = T))
test_X_impute$revol_util    <- impute(test_X_impute$revol_util, val = mean(train_X$revol_util, na.rm = T))
test_X_impute$monthly_payment <- impute(test_X_impute$monthly_payment, val = mean(train_X$monthly_payment, na.rm = T))
cat.cols <- !num.cols
train_X_impute[, cat.cols] <- lapply(train_X_impute[, cat.cols],
FUN = impute,
method = modus)
test_X_impute[, cat.cols] <- mapply(test_X_impute[, cat.cols],
FUN = impute,
val = sapply(train_X[, cat.cols], modus, na.rm = T))
colMeans(is.na(train_X_impute))  # -->no more missing values
colMeans(is.na(test_X_impute))   # -->no more missing values
?sapply
match <- regmatches(train_X_impute$address, regexec("[A-Z][A-Z]", train_X_impute$address))
match <- regmatches(test_X_impute$address, regexec("[A-Z][A-Z]", test_X_impute$address))
train_X_impute$state <- sapply(match, `[`, 1)
test_X_impute$state <- sapply
train_X_impute$state <- sapply(match, `[`, 1)
cats <- categories(train_X_encode[, c("State")], p = 10)
col.to.drop <- c('address')
train_X_impute = train_X_impute[ , ! names(train_X_impute) %in% col.to.drop]
test_X_impute = test_X_impute[ , ! names(test_X_impute) %in% col.to.drop]
head(train_X_impute)
M <-cor(train_X_impute[sapply(train_X_impute,is.numeric)])
corrplot(M, type="upper", order="hclust",col=brewer.pal(n=8, name="RdYlBu"))
cols.to.drop <- c('earliest_cr_line', 'date_funded', 'address')
train_X_impute = train_X_impute[ , ! names(train_X_impute) %in% cols.to.drop]
test_X_impute = test_X_impute[ , ! names(test_X_impute) %in% cols.to.drop]
ls.str(train_X_impute)
ls.str(test_X_impute)
vec <- c('application_type','emp_length', 'emp_title', 'grade',
'home_status', 'income_verif_status', 'state',
'home_status_flag', 'sub_grade', 'term')
train_X_fe <- train_X_impute
test_X_fe <- test_X_impute
train_X_fe <- as.data.frame(unclass(train_X_fe), stringsAsFactors = T)
test_X_fe <- as.data.frame(unclass(test_X_fe), stringsAsFactors = T)
num.cols <- sapply(train_X_fe, is.numeric)
mean_train <- colMeans(train_X_fe[, num.cols])
sd_train <- sapply(train_X_fe[, num.cols], sd)
train_X_fe[, num.cols] <- scale(train_X_fe[, num.cols], center = TRUE, scale = TRUE)
num.cols <- sapply(test_X_fe, is.numeric)
mean_train <- colMeans(test_X_fe[, num.cols])
sd_train <- sapply(test_X_fe[, num.cols], sd)
test_X_fe[, num.cols] <- scale(test_X_fe[, num.cols], center = TRUE, scale = TRUE)
train_y <- as.factor(train_y)
library(randomForest)
set.seed(1)
#small glitch
#train_X_fe <- train_X_fe[train_X_fe$state != 'WN',]
########################################################
class(train_X_fe_mod$state)
train_X_fe_mod <- droplevels(train_X_fe, exclude = "WY")
colMeans(is.na(train_X_fe))
colMeans(is.na(test_X_fe))
fit <- randomForest(train_y ~.,data = train_X_fe, mtry = 5, ntree = 25)
fit <- randomForest(x = train_X_fe, y = train_y, mtry = 5, ntree = 25)
y_estimate <- predict(fit,xtest)
cf.test <- table(y_estimate,train_y)
## id is character en default is numeric
y_estimate <- as.numeric(as.character(y_estimate))
test_X$id <- as.character(test_X$id)
### DATA CLEANING ###
train <- read.csv("train.csv")
getwd()
setwd("./GitHub/ml21-group07/data/bronze")
### DATA CLEANING ###
train <- read.csv("train.csv")
test_X <- read.csv("test.csv")
head(train)
train_X <- subset(train, select = -c(default))
train_y <- train$default
ls.str(train_X)
CrossTable(train$default)
library(gmodels)
library(corrplot)
library(RColorBrewer)
CrossTable(train$default)
CrossTable(train$num_bankrupts)
CrossTable(train_X_fe$state)
train_X_impute <- train_X
test_X_impute <- test_X
colMeans(is.na(train_X_impute))
colMeans(is.na(test_X_impute))
naFlag <- function(df, df_val = NULL) {
if (is.null(df_val)) {
df_val <- df
}
mask <- sapply(df_val, anyNA)
out <- lapply(df[mask], function(x)as.numeric(is.na(x)))
if (length(out) > 0) names(out) <- paste0(names(out), "_flag")
return(as.data.frame(out))
}
str(naFlag(df=train_X))
train_X_impute <- cbind(train_X_impute,
naFlag(df = train_X))
test_X_impute <- cbind(test_X_impute,
naFlag(df = test_X, df_val = train_X))
cols.dont.want <- c('annual_income_flag',
'emp_length_flag',
'emp_title_flag',
'monthly_payment_flag',
'num_bankrupts_flag',
'num_mortgages_flag',
'num_records_flag'  ,
'num_total_credit_flag',
'revol_util_flag')
train_X_impute = train_X_impute[ , ! names(train_X_impute) %in% cols.dont.want]
test_X_impute = test_X_impute[ , ! names(test_X_impute) %in% cols.dont.want]
#check:
train_X_impute
#check:
train_X_impute
#check:
head(train_X_impute)
impute <- function(x, method = mean, val = NULL) {
if (is.null(val)) {
val <- method(x, na.rm = TRUE)
}
x[is.na(x)] <- val
return(x)
}
modus <- function(x, na.rm = FALSE) {
if (na.rm) x <- x[!is.na(x)]
ux <- unique(x)
return(ux[which.max(tabulate(match(x, ux)))])
}
num.cols <- sapply(train_X_impute, is.numeric)
train_X_impute[, num.cols] <- lapply(train_X_impute[, num.cols],
FUN = impute,
method = mean)
#--------------------------------------------------------------STRANGE
test_X_impute[, num.cols] <- mapply(test_X_impute[, num.cols],
FUN = impute,
val = mean(train_X$num.cols ,na.rm = T))
#--------------------------------------------------------------STRANGE
test_X_impute[, num.cols] <- mapply(test_X_impute[, num.cols],
FUN = impute,
val = colMeans(train_X[,num.cols],na.rm = T))
num.cols
head(train_X_impute)
head(train_X_impute)
library(dummy)
match <- regmatches(train_X_impute$address, regexec("[A-Z][A-Z]", train_X_impute$address))
match <- regmatches(test_X_impute$address, regexec("[A-Z][A-Z]", test_X_impute$address))
train_X_impute$state <- sapply(match, `[`, 1)
cats <- categories(train_X_encode[, c("State")], p = 10)
cats <- categories(train_X_impute[, c("State")], p = 10)
train_X_impute
head(train_X_impute)
match <- regmatches(train_X_impute$address, regexec("[A-Z][A-Z]", train_X_impute$address))
match <- regmatches(test_X_impute$address, regexec("[A-Z][A-Z]", test_X_impute$address))
train_X_impute$state <- sapply(match, `[`, 1)
match <- regmatches(train_X_impute$address, regexec("[A-Z][A-Z]", train_X_impute$address))
match <- regmatches(test_X_impute$address, regexec("[A-Z][A-Z]", test_X_impute$address))
train_X_impute$state <- sapply(match, `[`, 1)
match <- regmatches(train_X_impute$address, regexec("[A-Z][A-Z]", train_X_impute$address))
train_X_impute$state <- sapply(match, `[`, 1)
match <- regmatches(test_X_impute$address, regexec("[A-Z][A-Z]", test_X_impute$address))
test_X_impute$state <- sapply(match, `[` ,1)
head(train_X_impute)
cats <- categories(train_X_impute[, c("State")], p = 10)
cats <- categories(train_X_impute[, c("state")], p = 10)
cats <- categories(train_X_impute[, c("state")], p = 10)
col.to.drop <- c('address')
train_X_impute = train_X_impute[ , ! names(train_X_impute) %in% col.to.drop]
test_X_impute = test_X_impute[ , ! names(test_X_impute) %in% col.to.drop]
head(train_X_impute)
cols.to.drop <- c('earliest_cr_line', 'date_funded', 'address')
train_X_impute = train_X_impute[ , ! names(train_X_impute) %in% cols.to.drop]
test_X_impute = test_X_impute[ , ! names(test_X_impute) %in% cols.to.drop]
train_X_impute
head(train_X_impute)
ls.str(train_X_impute)
ls.str(test_X_impute)
train_X_impute
head(train_X_impute)
train_X_fe <- train_X_impute
test_X_fe <- test_X_impute
train_X_fe <- as.data.frame(unclass(train_X_fe), stringsAsFactors = T)
test_X_fe <- as.data.frame(unclass(test_X_fe), stringsAsFactors = T)
head(train_X_fe)
num.cols <- sapply(train_X_fe, is.numeric) ## ID eruit?
mean_train <- colMeans(train_X_fe[, num.cols])
sd_train <- sapply(train_X_fe[, num.cols], sd)
train_X_fe[, num.cols] <- scale(train_X_fe[, num.cols], center = TRUE, scale = TRUE)
num.cols <- sapply(test_X_fe, is.numeric)
mean_train <- colMeans(test_X_fe[, num.cols])
sd_train <- sapply(test_X_fe[, num.cols], sd)
test_X_fe[, num.cols] <- scale(test_X_fe[, num.cols], center = TRUE, scale = TRUE)
train_X_fe
head(train_X_fe)
train_y <- as.factor(train_y)
head(train_y)
train_y
length(train_y))
length(train_y)
length(train_X_fe)
#small glitch
#train_X_fe <- train_X_fe[train_X_fe$state != 'WN',]
########################################################
class(train_X_fe_mod$state)
train_X_fe_mod <- droplevels(train_X_fe, exclude = "WY")
fit <- randomForest(x = train_X_fe, y = train_y, mtry = 5, ntree = 25)
library(randomForest)
set.seed(1)
fit <- randomForest(x = train_X_fe, y = train_y, mtry = 5, ntree = 25)
colMeans(is.na(train_X_fe))
colMeans(is.na(test_X_fe))
train_X_fe <- train_X_impute
test_X_fe <- test_X_impute
colMeans(is.na(train_X_fe))
vec <- c('application_type','emp_length', 'emp_title', 'grade',
'home_status', 'income_verif_status', 'state',
'home_status_flag', 'sub_grade', 'term')
train_X_fe <- train_X_impute
test_X_fe <- test_X_impute
colMeans(is.na(train_X_fe))
train_X_fe <- as.data.frame(unclass(train_X_fe), stringsAsFactors = T)
test_X_fe <- as.data.frame(unclass(test_X_fe), stringsAsFactors = T)
head(train_X_fe)
head(train_X_impute)
colMeans(is.na(train_X_impute)
colMeans(is.na(train_X_impute))
colMeans(is.na(train_X_impute))
fit <- randomForest(train_y ~.,data = train_X_fe, mtry = 5, ntree = 25)
fit <- randomForest(x = train_X_fe, y = train_y, mtry = 5, ntree = 25)
train <- read.csv("../data/bronze/train.csv")
hist(train_X$annual_income)
